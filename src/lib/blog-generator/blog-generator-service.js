/**
 * Blog Generator Service
 * Orchestrates the entire blog generation and publishing process
 */

import { getFirestore } from '@/lib/firebase-admin'
import { Timestamp } from 'firebase-admin/firestore'
import { generateSlug } from '@/lib/blog-utils'
import { generateKeywords, filterExistingKeywords, ZODIAC_SIGNS, TOPICS } from './keyword-generator'
import { generateBlogContent, generateInternalLinks } from './content-generator'
import { getBlogGenerationConfig } from './config'
import { generateFeaturedImageForKeyword } from '@/lib/blog-image-service'

const BLOGS_COLLECTION = 'blogs'

/**
 * Get all existing blog slugs from database
 * @returns {Promise<Array<string>>} Array of slugs
 */
async function getExistingSlugs() {
  try {
    const db = getFirestore()
    if (!db || typeof db.collection !== 'function') {
      throw new Error('Firebase Admin not initialized')
    }

    const snapshot = await db.collection(BLOGS_COLLECTION).get()
    const slugs = []
    
    snapshot.forEach((doc) => {
      const data = doc.data()
      if (data.slug) {
        slugs.push(data.slug)
      }
    })
    
    return slugs
  } catch (error) {
    console.error('Error fetching existing slugs:', error)
    return []
  }
}

/**
 * Add internal links to blog content
 * @param {string} content - Blog HTML content
 * @param {Array<Object>} links - Array of link objects
 * @returns {string} Content with internal links added
 */
function addInternalLinks(content, links) {
  if (!links || links.length === 0) {
    return content
  }

  // Create links HTML
  const linksHtml = `
    <div style="margin: 30px 0; padding: 20px; background-color: #f8f9fa; border-radius: 8px;">
      <h3>Related Articles</h3>
      <ul style="list-style: none; padding: 0;">
        ${links.map(link => `<li style="margin: 10px 0;"><a href="${link.url}" style="color: #0066cc; text-decoration: none;">${link.text}</a></li>`).join('')}
      </ul>
    </div>
  `

  // Add before closing tags or at the end
  if (content.includes('</h2>')) {
    // Add after last H2 section
    const lastH2Index = content.lastIndexOf('</h2>')
    return content.slice(0, lastH2Index + 5) + linksHtml + content.slice(lastH2Index + 5)
  } else {
    // Add at the end
    return content + linksHtml
  }
}

/**
 * Create and publish a blog post
 * @param {Object} keyword - Keyword object
 * @param {Object} generatedContent - Generated content from AI
 * @param {Array<Object>} internalLinks - Internal links to add
 * @returns {Promise<Object>} Created blog object
 */
async function createBlogPost(keyword, generatedContent, internalLinks = []) {
  try {
    const db = getFirestore()
    if (!db || typeof db.collection !== 'function') {
      throw new Error('Firebase Admin not initialized')
    }

    // Generate slug
    const slug = keyword.slug || generateSlug(keyword.title)

    // Check if slug already exists
    const existingBlog = await db
      .collection(BLOGS_COLLECTION)
      .where('slug', '==', slug)
      .limit(1)
      .get()

    if (!existingBlog.empty) {
      console.log(`Blog with slug "${slug}" already exists, skipping...`)
      return null
    }

    // Add internal links to content
    let finalContent = generatedContent.content
    if (internalLinks.length > 0) {
      finalContent = addInternalLinks(finalContent, internalLinks)
    }

    // Generate a topic-relevant featured image using AI (no local assets)
    const featuredImageUrl = await generateFeaturedImageForKeyword(keyword)

    // Prepare blog data
    const now = Timestamp.now()
    const blogData = {
      title: generatedContent.title,
      slug: slug,
      content: finalContent,
      metaTitle: generatedContent.metaTitle,
      metaDescription: generatedContent.metaDescription,
      author: 'NiraLive Astro',
      tags: [keyword.zodiac, keyword.topic, keyword.timeType === 'yearly' ? `${keyword.year}` : keyword.month || ''],
      // AI-generated image based on zodiac/topic; may be null if generation fails
      featuredImage: featuredImageUrl || null,
      status: 'published', // Auto-publish
      publishedAt: now,
      updatedAt: now,
      createdAt: now,
      // Metadata for tracking
      autoGenerated: true,
      generationDate: now.toDate().toISOString(),
      keyword: {
        zodiac: keyword.zodiac,
        topic: keyword.topic,
        timeType: keyword.timeType,
        year: keyword.year,
        month: keyword.month,
      },
    }

    // Add to Firestore
    const docRef = await db.collection(BLOGS_COLLECTION).add(blogData)

    console.log(`‚úÖ Created blog: "${generatedContent.title}" (ID: ${docRef.id})`)

    return {
      id: docRef.id,
      ...blogData,
      publishedAt: blogData.publishedAt?.toDate?.()?.toISOString() || null,
    }
  } catch (error) {
    console.error('Error creating blog post:', error)
    throw error
  }
}

/**
 * Filter keywords based on user selections
 * @param {Array<Object>} keywords - Array of keyword objects
 * @param {Object} filters - Filter options
 * @returns {Array<Object>} Filtered keywords
 */
function filterKeywords(keywords, filters) {
  let filtered = keywords

  // Filter by zodiac signs
  if (filters.zodiacs && Array.isArray(filters.zodiacs) && filters.zodiacs.length > 0) {
    filtered = filtered.filter(k => filters.zodiacs.includes(k.zodiac))
  }

  // Filter by topics
  if (filters.topics && Array.isArray(filters.topics) && filters.topics.length > 0) {
    filtered = filtered.filter(k => filters.topics.includes(k.topic))
  }

  // Filter by time types
  if (filters.timeTypes && Array.isArray(filters.timeTypes) && filters.timeTypes.length > 0) {
    filtered = filtered.filter(k => filters.timeTypes.includes(k.timeType))
  }

  return filtered
}

/**
 * Generate and publish blogs based on configuration
 * @param {Object} options - Generation options
 * @param {number} options.maxBlogs - Maximum number of blogs to generate (default: 10)
 * @param {boolean} options.dryRun - If true, don't actually create blogs (default: false)
 * @param {Object} options.filters - Filter options (zodiacs, topics, timeTypes, year, monthsAhead)
 * @returns {Promise<Object>} Generation results
 */
export async function generateBlogs(options = {}) {
  const {
    maxBlogs = 10,
    dryRun = false,
    filters = {},
  } = options

  try {
    console.log('üöÄ Starting blog generation...')
    
    // Get configuration
    const config = getBlogGenerationConfig()
    
    // Override config with filters if provided
    if (filters.year) {
      config.currentYear = filters.year
    }
    if (filters.monthsAhead !== undefined) {
      config.monthsAhead = filters.monthsAhead
    }
    
    // Get existing slugs to avoid duplicates
    const existingSlugs = await getExistingSlugs()
    console.log(`üìä Found ${existingSlugs.length} existing blogs`)
    
    // Generate keywords
    const allKeywords = generateKeywords(config)
    console.log(`üîë Generated ${allKeywords.length} keyword combinations`)
    
    // Apply user filters
    let filteredKeywords = filterKeywords(allKeywords, filters)
    console.log(`üéØ After filters: ${filteredKeywords.length} keywords`)

    // Filter out existing ones
    let newKeywords = filterExistingKeywords(filteredKeywords, existingSlugs)
    console.log(`‚ú® ${newKeywords.length} new keywords to process`)

    // When fewer new keywords than requested, expand filters to reach the requested count
    // (e.g. user selects Cancer+Love, wants 3, but only 1 new combo exists ‚Üí add more signs/topics)
    if (newKeywords.length < maxBlogs && (filters.zodiacs?.length > 0 || filters.topics?.length > 0)) {
      const expandedZodiacs = filters.zodiacs?.length ? [...filters.zodiacs] : ZODIAC_SIGNS
      const expandedTopics = filters.topics?.length ? [...filters.topics] : TOPICS

      // Add unselected zodiac signs first
      for (const sign of ZODIAC_SIGNS) {
        if (newKeywords.length >= maxBlogs) break
        if (expandedZodiacs.includes(sign)) continue
        expandedZodiacs.push(sign)
        const expFilters = { ...filters, zodiacs: expandedZodiacs, topics: expandedTopics }
        const expFiltered = filterKeywords(allKeywords, expFilters)
        const expNew = filterExistingKeywords(expFiltered, existingSlugs)
        if (expNew.length >= maxBlogs) {
          newKeywords = expNew
          console.log(`üìà Expanded to ${expandedZodiacs.length} zodiac(s) ‚Üí ${newKeywords.length} new keywords`)
          break
        }
        newKeywords = expNew
      }

      // If still not enough, add unselected topics
      if (newKeywords.length < maxBlogs) {
        for (const topic of TOPICS) {
          if (newKeywords.length >= maxBlogs) break
          if (expandedTopics.includes(topic)) continue
          expandedTopics.push(topic)
          const expFilters = { ...filters, zodiacs: expandedZodiacs, topics: expandedTopics }
          const expFiltered = filterKeywords(allKeywords, expFilters)
          const expNew = filterExistingKeywords(expFiltered, existingSlugs)
          if (expNew.length >= maxBlogs) {
            newKeywords = expNew
            console.log(`üìà Expanded to ${expandedTopics.length} topic(s) ‚Üí ${newKeywords.length} new keywords`)
            break
          }
          newKeywords = expNew
        }
      }
    }
    
    if (newKeywords.length === 0) {
      return {
        success: true,
        message: 'No new blogs to generate',
        generated: 0,
        skipped: 0,
        errors: [],
      }
    }

    // Limit to maxBlogs
    const keywordsToProcess = newKeywords.slice(0, maxBlogs)
    console.log(`üìù Processing ${keywordsToProcess.length} blogs...`)

    const results = {
      generated: 0,
      skipped: 0,
      errors: [],
      blogs: [],
      dryRunWouldGenerate: [], // Titles that would be generated in dry run
    }

    // Process each keyword
    for (let i = 0; i < keywordsToProcess.length; i++) {
      const keyword = keywordsToProcess[i]
      console.log(`\n[${i + 1}/${keywordsToProcess.length}] Generating: "${keyword.title}"`)

      try {
        if (dryRun) {
          console.log(`  [DRY RUN] Would generate blog for: ${keyword.title}`)
          results.skipped++
          results.dryRunWouldGenerate.push({ title: keyword.title, slug: keyword.slug })
          continue
        }

        // Generate content
        console.log('  ü§ñ Generating content with AI...')
        const generatedContent = await generateBlogContent(keyword, {
          useHighLevelModel: config.useHighLevelModel,
          model: config.aiModel,
        })

        // Generate internal links
        const internalLinks = generateInternalLinks(
          keyword.zodiac,
          keyword.topic,
          keyword,
          existingSlugs
        )

        // Create and publish blog
        console.log('  üíæ Creating blog post...')
        const blog = await createBlogPost(keyword, generatedContent, internalLinks)

        if (blog) {
          results.generated++
          results.blogs.push({
            id: blog.id,
            title: blog.title,
            slug: blog.slug,
          })
          
          // Add to existing slugs for next iterations
          existingSlugs.push(blog.slug)
          
          // Rate limiting: wait between generations to avoid API rate limits
          if (i < keywordsToProcess.length - 1) {
            const delay = config.delayBetweenBlogs || 2000 // 2 seconds default
            console.log(`  ‚è≥ Waiting ${delay}ms before next generation...`)
            await new Promise(resolve => setTimeout(resolve, delay))
          }
        } else {
          results.skipped++
        }
      } catch (error) {
        console.error(`  ‚ùå Error generating blog for "${keyword.title}":`, error)
        results.errors.push({
          keyword: keyword.title,
          error: error.message,
        })
      }
    }

    console.log(`\n‚úÖ Blog generation complete!`)
    console.log(`   Generated: ${results.generated}`)
    console.log(`   Skipped: ${results.skipped}`)
    console.log(`   Errors: ${results.errors.length}`)

    const response = {
      success: true,
      generated: results.generated,
      skipped: results.skipped,
      errors: results.errors,
      blogs: results.blogs,
    }
    if (dryRun && results.dryRunWouldGenerate?.length) {
      response.dryRunWouldGenerate = results.dryRunWouldGenerate
    }
    return response
  } catch (error) {
    console.error('‚ùå Fatal error in blog generation:', error)
    return {
      success: false,
      error: error.message,
      generated: 0,
      skipped: 0,
      errors: [error.message],
    }
  }
}
