/**
 * Admin API: Generate a publish-ready blog from a natural-language topic.
 * Runs intent analysis, SEO structure, content, image specs, internal links.
 * Optionally saves to Firestore (existing blog collection).
 */

import { requireAdminAuth } from '@/lib/admin-auth'
import { getFirestore } from '@/lib/firebase-admin'
import { Timestamp } from 'firebase-admin/firestore'
import { runTopicToBlogPipeline } from '@/lib/blog-generator/topic-to-blog-pipeline'
import { generateFeaturedImageForTopicBlog } from '@/lib/blog-image-service'
import { generateSlug } from '@/lib/blog-utils'

const BLOGS_COLLECTION = 'blogs'

export async function POST(request) {
  try {
    const body = await request.json().catch(() => ({}))
    const authError = await requireAdminAuth(request, body)
    if (authError) return authError

    const topic = typeof body.topic === 'string' ? body.topic.trim() : ''
    const publish = body.publish !== false

    if (!topic) {
      return Response.json(
        { success: false, error: 'Topic is required' },
        { status: 400 }
      )
    }

    const pipelineResult = await runTopicToBlogPipeline(topic)

    // Optional: save to Firestore (same schema as existing blogs)
    let saved = null
    const db = getFirestore()
    if (db && typeof db.collection === 'function') {
      const blogsRef = db.collection(BLOGS_COLLECTION)

      // Ensure we never reuse an existing slug; auto-append numeric suffixes
      const baseSlug = (pipelineResult.slug && pipelineResult.slug.trim()) || generateSlug(pipelineResult.title)
      let finalSlug = baseSlug
      let counter = 2

      // Loop until we find a free slug
      // This guarantees no slug-level cannibalization even for similar topics
      /* eslint-disable no-constant-condition */
      while (true) {
        const snapshot = await blogsRef.where('slug', '==', finalSlug).limit(1).get()
        if (snapshot.empty) break
        finalSlug = `${baseSlug}-${counter++}`
      }
      /* eslint-enable no-constant-condition */

      // Update pipeline result to reflect the final unique slug
      pipelineResult.slug = finalSlug

      const now = Timestamp.now()
      // Generate an AI image strictly based on this topic/blog payload
      const featuredImageUrl = await generateFeaturedImageForTopicBlog(pipelineResult)

        const blogData = {
        title: pipelineResult.title,
        slug: pipelineResult.slug,
        content: pipelineResult.content_html,
        metaTitle: pipelineResult.meta_title,
        metaDescription: pipelineResult.meta_description,
        author: 'NiraLive Astro',
        tags: pipelineResult.tags,
        // AI-generated, topic-based image URL (may be null on failure)
        featuredImage: featuredImageUrl || null,
        images: pipelineResult.images,
        internal_links: pipelineResult.internal_links,
        category: pipelineResult.category,
        status: publish ? 'published' : 'draft',
        publishedAt: publish ? now : null,
        updatedAt: now,
        createdAt: now,
        autoGenerated: true,
        generationDate: now.toDate().toISOString(),
        sourceTopic: topic,
      }

      const docRef = await db.collection(BLOGS_COLLECTION).add(blogData)
      saved = { id: docRef.id, slug: pipelineResult.slug }
    }

    return Response.json({
      success: true,
      blog: pipelineResult,
      saved,
    }, { status: 200 })
  } catch (error) {
    console.error('[generate-blog-from-topic]', error)
    return Response.json(
      {
        success: false,
        error: error.message || 'Failed to generate blog from topic',
      },
      { status: 500 }
    )
  }
}
