/**
 * Automated Blog Generation Admin Page
 * UI for managing automated blog generation
 */

'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { useToast } from '@/hooks/useToast'
import { ToastContainer } from '@/components/Toast'
import { Sparkles, Play, RefreshCw, Settings, CheckCircle, XCircle, Clock, FileText, PenLine } from 'lucide-react'
import { ZODIAC_SIGNS, TOPICS } from '@/lib/blog-generator/keyword-generator'
import '../admin-blog.css'
import './generate.css'

const ADMIN_PASSCODE = 'Spacenos.nxt@global'
const PASSCODE_STORAGE_KEY = 'admin_passcode_verified'

export default function BlogGenerationPage() {
  const router = useRouter()
  const { toasts, removeToast, success: showSuccess, error: showError } = useToast()
  const [isPasscodeVerified, setIsPasscodeVerified] = useState(false)
  const [showPasscodeModal, setShowPasscodeModal] = useState(false)
  const [isReady, setIsReady] = useState(false) // avoid partial render before client hydration
  const [passcodeInput, setPasscodeInput] = useState('')
  const [passcodeError, setPasscodeError] = useState('')
  
  // Generation state
  const [generating, setGenerating] = useState(false)
  const [generationHistory, setGenerationHistory] = useState([])
  const [config, setConfig] = useState({
    maxBlogs: 10,
    dryRun: false,
    // Blog type filters
    selectedZodiacs: [], // Empty = all zodiacs
    selectedTopics: [], // Empty = all topics
    selectedTimeTypes: [], // Empty = all time types
    year: new Date().getFullYear(),
    monthsAhead: 3,
  })
  
  // Topic-to-blog (admin input field)
  const [topicInput, setTopicInput] = useState('')
  const [generatingFromTopic, setGeneratingFromTopic] = useState(false)
  const [topicResult, setTopicResult] = useState(null)

  // Stats
  const [stats, setStats] = useState({
    totalGenerated: 0,
    todayGenerated: 0,
    lastGeneration: null,
  })

  // Check authentication once on client
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const verified = sessionStorage.getItem(PASSCODE_STORAGE_KEY)
      if (verified === 'true') {
        setIsPasscodeVerified(true)
      } else {
        setShowPasscodeModal(true)
      }
      setIsReady(true)
    }
  }, [])

  // Load stats on mount
  useEffect(() => {
    if (isPasscodeVerified) {
      loadStats()
      loadGenerationHistory()
    }
  }, [isPasscodeVerified])

  const handlePasscodeSubmit = (e) => {
    e.preventDefault()
    setPasscodeError('')
    
    if (passcodeInput === ADMIN_PASSCODE) {
      setIsPasscodeVerified(true)
      setShowPasscodeModal(false)
      if (typeof window !== 'undefined') {
        sessionStorage.setItem(PASSCODE_STORAGE_KEY, 'true')
      }
      setPasscodeInput('')
    } else {
      setPasscodeError('Incorrect passcode. Please try again.')
      setPasscodeInput('')
    }
  }

  const loadStats = async () => {
    try {
      // Get auto-generated blogs count
      const response = await fetch('/api/blog?status=published', {
        headers: {
          'Authorization': `Bearer ${ADMIN_PASSCODE}`,
        },
      })
      const data = await response.json()
      
      if (data.blogs) {
        const autoGenerated = data.blogs.filter(b => b.autoGenerated)
        const today = new Date().toDateString()
        const todayGenerated = autoGenerated.filter(b => {
          const pubDate = b.publishedAt ? new Date(b.publishedAt).toDateString() : null
          return pubDate === today
        })
        
        const lastGen = autoGenerated.length > 0 
          ? autoGenerated.sort((a, b) => new Date(b.publishedAt) - new Date(a.publishedAt))[0]
          : null

        setStats({
          totalGenerated: autoGenerated.length,
          todayGenerated: todayGenerated.length,
          lastGeneration: lastGen ? {
            date: lastGen.publishedAt,
            title: lastGen.title,
          } : null,
        })
      }
    } catch (error) {
      console.error('Error loading stats:', error)
    }
  }

  const loadGenerationHistory = () => {
    // Load from localStorage (could be enhanced with API)
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem('blog_generation_history')
      if (stored) {
        try {
          setGenerationHistory(JSON.parse(stored))
        } catch (e) {
          console.error('Error parsing history:', e)
        }
      }
    }
  }

  const saveGenerationHistory = (result) => {
    const historyItem = {
      id: Date.now(),
      timestamp: new Date().toISOString(),
      ...result,
    }
    
    const updated = [historyItem, ...generationHistory].slice(0, 20) // Keep last 20
    
    if (typeof window !== 'undefined') {
      localStorage.setItem('blog_generation_history', JSON.stringify(updated))
    }
    
    setGenerationHistory(updated)
  }

  const handleGenerate = async () => {
    if (generating) return
    
    setGenerating(true)
    showSuccess('Starting blog generation...')

    try {
      const response = await fetch('/api/cron/generate-blogs', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${ADMIN_PASSCODE}`,
        },
        body: JSON.stringify({
          max: config.maxBlogs,
          dryRun: config.dryRun,
          filters: {
            zodiacs: config.selectedZodiacs,
            topics: config.selectedTopics,
            timeTypes: config.selectedTimeTypes,
            year: config.year,
            monthsAhead: config.monthsAhead,
          },
        }),
      })

      const result = await response.json()

      if (response.ok && result.success) {
        showSuccess(`Successfully generated ${result.generated} blog(s)!`)
        saveGenerationHistory(result)
        loadStats()
      } else {
        showError(result.error || 'Failed to generate blogs')
      }
    } catch (error) {
      console.error('Generation error:', error)
      showError('Error generating blogs: ' + error.message)
    } finally {
      setGenerating(false)
    }
  }

  const handleGenerateFromTopic = async () => {
    const topic = (topicInput || '').trim()
    if (!topic || generatingFromTopic) return
    setGeneratingFromTopic(true)
    setTopicResult(null)
    showSuccess('Generating blog from topic...')
    try {
      const response = await fetch('/api/admin/generate-blog-from-topic', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${ADMIN_PASSCODE}`,
        },
        body: JSON.stringify({ topic, publish: true }),
      })
      const data = await response.json()
      if (data.success) {
        setTopicResult(data)
        showSuccess(data.saved ? `Blog published: ${data.blog.title}` : (data.error || 'Blog generated (not saved: slug exists)'))
        if (data.saved) loadStats()
      } else {
        showError(data.error || 'Failed to generate blog')
        setTopicResult({ error: data.error })
      }
    } catch (err) {
      showError('Error: ' + err.message)
      setTopicResult({ error: err.message })
    } finally {
      setGeneratingFromTopic(false)
    }
  }

  const handleTestGeneration = async () => {
    if (generating) return
    
    setGenerating(true)
    showSuccess('Testing blog generation (dry run)...')

    try {
      const response = await fetch('/api/cron/generate-blogs?max=1&dryRun=true', {
        headers: {
          'Authorization': `Bearer ${ADMIN_PASSCODE}`,
        },
      })

      const result = await response.json()
      
      if (response.ok) {
        showSuccess('Dry run completed successfully! Check console for details.')
        console.log('Dry run result:', result)
      } else {
        showError(result.error || 'Dry run failed')
      }
    } catch (error) {
      console.error('Test error:', error)
      showError('Error testing generation: ' + error.message)
    } finally {
      setGenerating(false)
    }
  }

  // Avoid rendering full layout until we've checked auth on client
  if (!isReady) {
    return (
      <div className="admin-container">
        <div className="passcode-modal-overlay">
          <div className="passcode-modal">
            <h2>Loading admin tools‚Ä¶</h2>
            <p>Please wait a moment.</p>
          </div>
        </div>
        <ToastContainer toasts={toasts} removeToast={removeToast} />
      </div>
    )
  }

  if (!isPasscodeVerified) {
    return (
      <div className="admin-container">
        <div className="passcode-modal-overlay">
          <div className="passcode-modal">
            <h2>Admin Authentication</h2>
            <p>Please enter the admin passcode to continue.</p>
            <form onSubmit={handlePasscodeSubmit}>
              <input
                type="password"
                value={passcodeInput}
                onChange={(e) => setPasscodeInput(e.target.value)}
                placeholder="Enter passcode"
                className="passcode-input"
                autoFocus
              />
              {passcodeError && <p className="passcode-error">{passcodeError}</p>}
              <button type="submit" className="passcode-submit">
                Verify
              </button>
            </form>
          </div>
        </div>
        <ToastContainer toasts={toasts} removeToast={removeToast} />
      </div>
    )
  }

  return (
    <div className="admin-container">
      <div className="admin-header">
        <div className="admin-header-content">
          <div className="admin-header-left">
            <Sparkles className="admin-header-icon" />
            <div>
              <h1>Automated Blog Generation</h1>
              <p>Generate SEO-optimized astrology blogs automatically</p>
            </div>
          </div>
          <button
            onClick={() => router.push('/admin/blog')}
            className="admin-back-button"
          >
            ‚Üê Back to Blog Management
          </button>
        </div>
      </div>

      <div className="generation-container">
        {/* Stats Cards */}
        <div className="stats-grid">
          <div className="stat-card">
            <div className="stat-icon">
              <FileText />
            </div>
            <div className="stat-content">
              <div className="stat-value">{stats.totalGenerated}</div>
              <div className="stat-label">Total Generated</div>
            </div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">
              <Clock />
            </div>
            <div className="stat-content">
              <div className="stat-value">{stats.todayGenerated}</div>
              <div className="stat-label">Generated Today</div>
            </div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">
              {stats.lastGeneration ? <CheckCircle /> : <XCircle />}
            </div>
            <div className="stat-content">
              <div className="stat-value">
                {stats.lastGeneration 
                  ? new Date(stats.lastGeneration.date).toLocaleDateString()
                  : 'Never'}
              </div>
              <div className="stat-label">Last Generation</div>
            </div>
          </div>
        </div>

        {/* Generate from topic (admin input) */}
        <div className="generation-panel topic-panel">
          <div className="panel-header">
            <PenLine className="panel-icon" />
            <h2>Generate from topic</h2>
          </div>
          <p className="topic-description">
            Type any natural-language topic. The system will produce a full SEO-optimized blog (title, slug, content, images, internal links) and publish it.
          </p>
          <div className="topic-controls">
            <input
              type="text"
              placeholder="e.g. aries career problems in 2026, top 10 astrologers of india, love marriage chances for virgo female"
              value={topicInput}
              onChange={(e) => setTopicInput(e.target.value)}
              onKeyDown={(e) => e.key === 'Enter' && handleGenerateFromTopic()}
              disabled={generatingFromTopic}
              className="topic-input"
            />
            <button
              type="button"
              onClick={handleGenerateFromTopic}
              disabled={!topicInput.trim() || generatingFromTopic}
              className="btn-generate btn-topic"
            >
              {generatingFromTopic ? (
                <>
                  <RefreshCw className="spinning" />
                  Generating...
                </>
              ) : (
                <>
                  <Sparkles />
                  Generate &amp; publish
                </>
              )}
            </button>
          </div>
          {topicResult && (
            <div className={`topic-result ${topicResult.error ? 'topic-result-error' : 'topic-result-success'}`}>
              {topicResult.error && <p><strong>Error:</strong> {topicResult.error}</p>}
              {topicResult.blog && (
                <>
                  <p><strong>Title:</strong> {topicResult.blog.title}</p>
                  <p><strong>Slug:</strong> {topicResult.blog.slug}</p>
                  {topicResult.saved && (
                    <p>
                      <a href={`/blog/${topicResult.blog.slug}`} target="_blank" rel="noopener noreferrer">
                        View blog ‚Üí
                      </a>
                    </p>
                  )}
                </>
              )}
            </div>
          )}
        </div>

        {/* Generation Controls */}
        <div className="generation-panel">
          <div className="panel-header">
            <Settings className="panel-icon" />
            <h2>Generation Settings (keyword trail)</h2>
          </div>
          
          <div className="generation-controls">
            <div className="control-group">
              <label htmlFor="maxBlogs">Number of Blogs to Generate</label>
              <input
                id="maxBlogs"
                type="number"
                min="1"
                max="100"
                step="1"
                value={config.maxBlogs}
                onChange={(e) => {
                  const val = e.target.value
                  if (val === '' || (!isNaN(val) && parseInt(val) >= 1)) {
                    setConfig({ ...config, maxBlogs: val === '' ? '' : parseInt(val) || 1 })
                  }
                }}
                onBlur={(e) => {
                  const val = parseInt(e.target.value) || 1
                  setConfig({ ...config, maxBlogs: Math.max(1, Math.min(100, val)) })
                }}
                disabled={generating}
              />
              <small>Maximum blogs to generate in this run (any number from 1-100)</small>
            </div>

            {/* Blog Type Filters */}
            <div className="control-group">
              <label>Zodiac Signs (Leave empty for all)</label>
              <div className="multi-select-container">
                <div className="multi-select-grid">
                  {ZODIAC_SIGNS.map((sign) => (
                    <label key={sign} className="multi-select-item">
                      <input
                        type="checkbox"
                        checked={config.selectedZodiacs.includes(sign)}
                        onChange={(e) => {
                          if (e.target.checked) {
                            setConfig({ ...config, selectedZodiacs: [...config.selectedZodiacs, sign] })
                          } else {
                            setConfig({ ...config, selectedZodiacs: config.selectedZodiacs.filter(s => s !== sign) })
                          }
                        }}
                        disabled={generating}
                      />
                      <span>{sign}</span>
                    </label>
                  ))}
                </div>
                {config.selectedZodiacs.length > 0 && (
                  <button
                    type="button"
                    onClick={() => setConfig({ ...config, selectedZodiacs: [] })}
                    className="clear-selection"
                  >
                    Clear Selection ({config.selectedZodiacs.length} selected)
                  </button>
                )}
              </div>
            </div>

            <div className="control-group">
              <label>Topics (Leave empty for all)</label>
              <div className="multi-select-container">
                <div className="multi-select-grid">
                  {TOPICS.map((topic) => (
                    <label key={topic} className="multi-select-item">
                      <input
                        type="checkbox"
                        checked={config.selectedTopics.includes(topic)}
                        onChange={(e) => {
                          if (e.target.checked) {
                            setConfig({ ...config, selectedTopics: [...config.selectedTopics, topic] })
                          } else {
                            setConfig({ ...config, selectedTopics: config.selectedTopics.filter(t => t !== topic) })
                          }
                        }}
                        disabled={generating}
                      />
                      <span>{topic}</span>
                    </label>
                  ))}
                </div>
                {config.selectedTopics.length > 0 && (
                  <button
                    type="button"
                    onClick={() => setConfig({ ...config, selectedTopics: [] })}
                    className="clear-selection"
                  >
                    Clear Selection ({config.selectedTopics.length} selected)
                  </button>
                )}
              </div>
            </div>

            <div className="control-group">
              <label>Time Types (Leave empty for all)</label>
              <div className="multi-select-container">
                <div className="multi-select-grid">
                  {[
                    { value: 'yearly', label: 'Yearly (e.g., "Career for Leo in 2026")' },
                    { value: 'monthly', label: 'Monthly (e.g., "Love for Virgo in February 2026")' },
                    { value: 'this-year', label: 'This Year (e.g., "Health for Scorpio this year")' },
                  ].map((timeType) => (
                    <label key={timeType.value} className="multi-select-item">
                      <input
                        type="checkbox"
                        checked={config.selectedTimeTypes.includes(timeType.value)}
                        onChange={(e) => {
                          if (e.target.checked) {
                            setConfig({ ...config, selectedTimeTypes: [...config.selectedTimeTypes, timeType.value] })
                          } else {
                            setConfig({ ...config, selectedTimeTypes: config.selectedTimeTypes.filter(t => t !== timeType.value) })
                          }
                        }}
                        disabled={generating}
                      />
                      <span>{timeType.label}</span>
                    </label>
                  ))}
                </div>
                {config.selectedTimeTypes.length > 0 && (
                  <button
                    type="button"
                    onClick={() => setConfig({ ...config, selectedTimeTypes: [] })}
                    className="clear-selection"
                  >
                    Clear Selection ({config.selectedTimeTypes.length} selected)
                  </button>
                )}
              </div>
            </div>

            <div className="control-group">
              <label>
                <input
                  type="checkbox"
                  checked={config.dryRun}
                  onChange={(e) => setConfig({ ...config, dryRun: e.target.checked })}
                  disabled={generating}
                />
                <span>Dry Run Mode (test without creating blogs)</span>
              </label>
            </div>

            <div className="action-buttons">
              <button
                onClick={handleTestGeneration}
                disabled={generating}
                className="btn-test"
              >
                <RefreshCw className={generating ? 'spinning' : ''} />
                Test Generation
              </button>
              
              <button
                onClick={handleGenerate}
                disabled={generating}
                className="btn-generate"
              >
                {generating ? (
                  <>
                    <RefreshCw className="spinning" />
                    Generating...
                  </>
                ) : (
                  <>
                    <Play />
                    Generate Blogs
                  </>
                )}
              </button>
            </div>
          </div>
        </div>

        {/* Generation History */}
        {generationHistory.length > 0 && (
          <div className="history-panel">
            <div className="panel-header">
              <Clock className="panel-icon" />
              <h2>Generation History</h2>
            </div>
            
            <div className="history-list">
              {generationHistory.map((item) => (
                <div key={item.id} className="history-item">
                  <div className="history-header">
                    <span className="history-date">
                      {new Date(item.timestamp).toLocaleString()}
                    </span>
                    <span className={`history-status ${item.success ? 'success' : 'error'}`}>
                      {item.success ? '‚úì Success' : '‚úó Failed'}
                    </span>
                  </div>
                  <div className="history-details">
                    Generated: {item.generated || 0} | 
                    Skipped: {item.skipped || 0} | 
                    Errors: {item.errors?.length || 0}
                  </div>
                  {item.blogs && item.blogs.length > 0 && (
                    <div className="history-blogs">
                      {item.blogs.slice(0, 3).map((blog) => (
                        <span key={blog.id} className="blog-tag">
                          {blog.title}
                        </span>
                      ))}
                      {item.blogs.length > 3 && (
                        <span className="blog-tag-more">
                          +{item.blogs.length - 3} more
                        </span>
                      )}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Info Panel */}
        <div className="info-panel">
          <h3>‚ÑπÔ∏è How It Works</h3>
          <ul>
            <li>Blogs are generated using AI (GPT-4o-mini) for high-quality content</li>
            <li>Each blog is unique and SEO-optimized</li>
            <li>Blogs are automatically published and appear in your blog listing</li>
            <li>Internal links are automatically added to related blogs</li>
            <li>All blogs are included in the sitemap for SEO</li>
          </ul>
          
          <h3>üìã Blog Types Generated</h3>
          <ul>
            <li><strong>Yearly:</strong> "Career for Leo in 2026"</li>
            <li><strong>Monthly:</strong> "Love for Virgo in February 2026"</li>
            <li><strong>This Year:</strong> "Health for Scorpio this year"</li>
          </ul>
          
          <h3>‚öôÔ∏è Automated Schedule</h3>
          <p>
            Blogs are automatically generated daily at 2 AM UTC via Vercel Cron Jobs.
            You can also trigger generation manually using the button above.
          </p>
        </div>
      </div>

      <ToastContainer toasts={toasts} removeToast={removeToast} />
    </div>
  )
}
